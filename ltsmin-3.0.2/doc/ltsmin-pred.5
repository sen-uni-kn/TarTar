'\" t
.\"     Title: ltsmin-pred
.\"    Author: [FIXME: author] [see http://www.docbook.org/tdg5/en/html/author]
.\" Generator: DocBook XSL Stylesheets vsnapshot <http://docbook.sf.net/>
.\"      Date: 12/17/2018
.\"    Manual: LTSmin Manual
.\"    Source: LTSmin 3.0.2
.\"  Language: English
.\"
.TH "LTSMIN\-PRED" "5" "12/17/2018" "LTSmin 3\&.0\&.2" "LTSmin Manual"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
ltsmin-pred \- Simple Predicate Language
.SH "SYNOPSIS"
.sp
LTSmin syntax for Simple Predicate Language formulae
.SH "DESCRIPTION"
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.B Table\ \&1.\ \&Language\(cqs operators and priority
.TS
allbox tab(:);
ltB ltB ltB.
T{
Priority
T}:T{
Operator
T}:T{
Meaning
T}
.T&
lt lt lt
lt lt lt
lt lt lt
lt lt lt
lt lt lt
lt lt lt
lt lt lt
lt lt lt
lt lt lt
lt lt lt
lt lt lt
lt lt lt
lt lt lt.
T{
.sp
0
T}:T{
.sp
true
T}:T{
.sp
constant true
T}
T{
.sp
0
T}:T{
.sp
false
T}:T{
.sp
constant false
T}
T{
.sp
0
T}:T{
.sp
maybe
T}:T{
.sp
constant maybe
T}
T{
.sp
1
T}:T{
.sp
* / %
T}:T{
.sp
multiplication, division and remainder
T}
T{
.sp
2
T}:T{
.sp
+ \-
T}:T{
.sp
addition, subtraction
T}
T{
.sp
3
T}:T{
.sp
< <= > >=
T}:T{
.sp
less than, less than or equal, greater than, greater than or equal
T}
T{
.sp
4
T}:T{
.sp
==
T}:T{
.sp
test operator (\fIstate variable name\fR==\fInumber\fR)
T}
T{
.sp
4
T}:T{
.sp
??
T}:T{
.sp
enabledness operator (\fIedge variable name\fR ?? \fIchunk\fR)
T}
T{
.sp
5
T}:T{
.sp
!
T}:T{
.sp
Logical negation
T}
T{
.sp
6
T}:T{
.sp
&&
T}:T{
.sp
Logical and
T}
T{
.sp
7
T}:T{
.sp
||
T}:T{
.sp
Logical or
T}
T{
.sp
8
T}:T{
.sp
<\->
T}:T{
.sp
Logical equivalence
T}
T{
.sp
9
T}:T{
.sp
\->
T}:T{
.sp
Logical implication
T}
.TE
.sp 1
.SH "EXAMPLE"
.sp
.if n \{\
.RS 4
.\}
.nf
init_0\e\&.x == 4 && (user_1\e\&.a\e[3\e] == 1 \-> register_2\e\&.y == 2)
.fi
.if n \{\
.RE
.\}
.sp
.sp
(Note the dot (\fI\&.\fR) and square braces (\fI[\fR and \fI]\fR) need to be escaped, as these symbols are used as keywords in the CTL and mu\-calculus languages)
.sp
This predicate example could be used in the prom frontends, to search for states where either x is not equal to 4 in (instance 0) the init proctype, or the element three of array a in (instance 1 of) proctype user is non\-zero, while y in (instance 2 of) proctype register is zero\&.
.sp
For variable naming consult the \-\-labels option in the PINS tools\&.
.SH "SEE ALSO"
.sp
\fBltsmin\fR(7), \fBetf2lts-seq\fR(1), \fBetf2lts-mc\fR(1) \fBltsmin-type-system\fR(5)
